# 测量3D点云数据中的几何体尺寸

本报告记录了本人使用3D数据常用的处理算法，对用3D点云数据代表的几何体进行尺寸测量。

## 1 引言

### 1.1 3D点云

3D点云数据是由大量的点组成的集合，每个点在空间中都有一个三维坐标 $(X, Y, Z)$ 。这些点通常用于描述物体的表面或环境的形状和结构。点云数据广泛应用于计算机视觉、三维建模、地图测绘、建筑设计等领域。

![3D Laser Scanning Point](figure/f01.png "3D Laser Scanning Point")

### 1.2 要进行几何尺寸测量的物体

一共有7个点云测量任务，包含9个不同的物体。每个任务都有来自不同视角拍摄的4个点云数据集。原始数据集格式为.npz，为在MATLAB上操作，已将它们全都转换为.mat文件。

![object1](figure/f02.png "object1"){height=174} ![object2](figure/f03.png "object2"){height=174} ![object3](figure/f04.png "object3"){height=174} ![object4](figure/f05.png "object4"){height=174} ![object5](figure/f06.png "object5"){height=174} ![object6](figure/f07.png "object6"){height=174} ![object7](figure/f08.png "object7"){height=174} ![object8](figure/f09.png "object8"){height=174} ![object9](figure/f10.png "object9"){height=174}

在该工作中值得注意的是：

- 第5个任务中要被测量的两个物体叠放在一起。
- 第6个任务中的点云数据集中同时存在两个物体。
- 第7个任务中要被测量的物体是手持物体拍摄的。

如下图：

![case1](figure/f11.png "case1"){height=174} ![case2](figure/f12.png "case2"){height=174} ![case3](figure/f13.png "case3"){height=174}

## 2 算法介绍

本节将对在该工作中所使用的算法进行介绍。

### 2.1 RANSAC

随机抽样一致（RANdom SAmple Consensus，RANSAC）算法。它采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。 RANSAC是一个非确定性算法，在某种意义上说，它会产生一个在一定概率下合理的结果，而更多次的迭代会使这一概率增加。此RANSAC算法在1981年由Fischler和Bolles首次提出。

RANSAC的基本假设是：

1. “内群”(inlier, 似乎译为内点群更加妥当，即正常数据，正确数据)数据可以通过几组模型的参数来叙述其分布，而“离群”(outlier,似乎译为外点群更加妥当，异常数​​据)数据则是不适合模型化的数据。
2. 数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。
3. RANSAC假定，给定一组（通常很小）的内点群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。

#### 2.1.1 范例

这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内点群以及外点群，其中内点群包含可以被拟合到线段上的点，而外点群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内点群的直线，因为最小二乘法会受外点群影响而影响其结果。而用RANSAC，可以只由内点群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率得到正确的拟合直线。

![RANSAC例子](figure/f14.png "RANSAC例子"){height=500}

#### 2.1.2 算法概述

算法的具体流程如下：

1. 在数据中随机选择若干个点设定为内点群
2. 计算拟合内点群的模型
3. 把其它刚才没选到的点带入刚才建立的模型中，根据一定的评价标准，计算该点是否属于内点群
4. 记下内点群数量
5. 重复以上步骤
6. 比较哪次计算中内点群数量最多，内点群最多的那次所建的模型就是我们所要求的解

这里有两个问题：

1. 一开始的时候我们要随机选择多少点（ $n$ ）
2. 以及要重复做多少次（ $k$ ）

#### 2.1.3 参数决定

假设每个点是真正内点群的几率是 $w$ ，则：
$$w = 真正内点群的数目 / 数据总数$$
通常我们不知道 $w$ 是多少， $w^𝑛$ 是所选择的 $𝑛$ 个点都是内点群的几率， $1−w^n$ 是所选择的 $n$ 个点至少有一个不是内点群的几率， $(1-w^{n})^{k}$ 是表示重复 $k$ 次都没有全部的 $n$ 个点都是内点群的几率，假设算法跑 $k$ 次以后成功的几率是 $p$ ，那么：

$$
\begin{array}{l}
1-p=\left(1-w^{n}\right)^{k} \\
p=1-\left(1-w^{n}\right)^{k} \\
k=\frac{\log (1-p)}{\log \left(1-w^{n}\right)}
\end{array}
$$

#### 2.1.4 实现

MATLAB已有对RANSAC算法的封装好的实现，即：

```MATLAB
[model,inlierIdx] = ransac(data,fitFcn,distFcn,sampleSize,maxDistance)
```

此外，针对各种点云数据拟合的问题，MATLAB也提供了相应的函数，且使用了RANSAC算法的优化变种：MSAC算法。即：

```MATLAB
% 拟合平面
model = pcfitplane(ptCloudIn,maxDistance)
% 拟合球面
model = pcfitsphere(ptCloudIn,maxDistance)
```

### 2.2 PCA降维

#### 2.2.1 主要概念

主成分分析（Principal Component Analysis, PCA）是一种广泛使用的降维技术，主要用于简化数据集的维数，同时保留数据中最重要的变化信息。从几何角度上看，PCA是找到一组正交的基向量，使得将数据旋转到新的基向量构成的空间后（这也意味着在不丢失维度信息的前提下，PCA变换是一种保距变换），能集中分布在少数几个基向量（对应着数据方差最大的方向）附近，此时就可以对数据进行降维处理。如下图：

![PCA降维例子](figure/f15.png "PCA降维例子"){height=500}

#### 2.2.2 PCA用于3D点云降维

在点云数据处理中，经常会有这样的问题：点云数据原本分布在同一平面上，但受噪声的影响，它们偏离了平面，如何找回点云数据原本所在的斜面，并给出点云数据在原始二维平面上的分布？这样的问题可以通过RANSAC方法去找到一个拟合平面来解决，这里介绍PCA方法在处理该问题上的能力和优势。
可以看到，上述问题实际上包含了两个要求：

1. 去噪。
2. 对数据进行降维。

由于点云数据原本分布在一个平面上，点云数据在该二维平面上位置的变化构成了数据方差的主要来源，又因为PCA能识别出数据的方差最大的方向，而噪声带来的方差比较小，且其方向无规律可言。因此，通过PCA找到数据的前两个主成分对应的特征子空间（数据的前两个变化最大的方向），就可以将该子空间视为点云原本分布的平面。然后，把点云数据投影到该平面上，就可以解决上文中的问题。而这一切，都仅仅是通过几个简单的矩阵运算来完成的。可以看到，这种方法相对于RANSAC方法而言，运算上更为简便和快捷，且能直接得到3D点云的二维分布，即，只有两个维度的点云数据，这极大地方便了后续的处理。

#### 2.2.3 实现

以下给出PCA降维的MATLAB实现代码作为参考：

```MATLAB
function [projected_points] = myPCA(points)
    % 中心化数据
    centered_points = points - mean(points);
    % 计算协方差矩阵
    cov_matrix = cov(centered_points);
    % 求解特征值和特征向量
    [V, D] = eig(cov_matrix);
    % 按特征值大小排序
    [~, idx] = sort(diag(D), 'descend');
    V = V(:, idx);
    % 将数据投影至前两个最大的特征值构成的特征空间
    projected_points = centered_points * V(:, 1:2);
end
```

### 2.3 最小圆覆盖算法

#### 2.3.1 点云数据处理中的最小圆覆盖问题

在对点云的圆平面进行检测时，往往会遇到圆平面的边界难以检测的问题，如下图：

![alt text](figure/f16.png){height=500}

我们显然对这个点云数据集代表的是一个圆平面这个猜测十分有把握，但是由于部分点云没有被检测到或被处理掉，导致圆的边界有所缺失，此时，我们很难通过精确的数学方程来解决这个问题。

#### 2.3.2 最小圆覆盖算法

上述问题可以抽象为：给定 $n$ 个点的平面坐标，求一个半径最小的圆，把 $n$ 个点全部包围。常用算法是 [Welzl's algorithm](http://www.sunshine2k.de/coding/java/Welzl/Welzl.html)。这里仅给出该方法的伪代码（如果从递归的角度去思考，把原本的要求得的包含 $|P|$ 个点的最小圆覆盖问题，分解为包含 $|R| <= 3$ 个点的子问题，然后从这些子问题递归回原问题，也许有助于理解该方法的证明。另外值得注意的是，下面的递归算法中，永远有 $|R| <= 3$ ，因为一开始 $|R| == 0$ ，而当 $|R|$ 在递推增加至 $|R| == 3$ 时，算法立即返回 ）：

```Fortran
/*
 * Calculates the sed of a set of Points. Call initially with R = empty set.
 * P is the set of points in the plane. R is the set of points lying on the boundary of the current circle.
 */

function sed(P,R)
{
    if (P is empty or |R| = 3) then
         D := calcDiskDirectly(R)
    else
        choose a p from P randomly;
        D := sed(P - {p}, R);
        if (p lies NOT inside D) then
            D := sed(P - {p}, R u {p});
    return D;
}
```

### 2.4 最小外接矩形算法

#### 2.4.1 点云数据处理中的矩形边界确定问题

在对点云的矩形平面进行检测时，往往会遇到矩形平面的边界确定的问题，如下图的左侧所示：

![alt text](figure/f17.png){height=500}

对于这个问题，一种直观的想法是，先使用PCA，将点云数据旋转到变化最大的两个方向上，然后找出上述点云的在横坐标轴上的最大差值和在纵坐标轴上的最大差值，将其视为矩形的长度和宽度，并以此将矩形平面区分出来。这在矩形的长度显著大于其宽度时较为有效。但是，如果矩形的长度和宽度相差不大，那么PCA就会倾向于将原始点云数据旋转到矩形的对角线上。如下图：

![alt text](figure/f18.png){height=500}

显然，这时候再沿用上述思路，就会出现较大的误差。

#### 2.4.2 最小外接矩形算法

最小外接矩形（Minimum Bounding Rectangle，MBR）算法可以解决上述问题，它用来找到包围给定点集的面积最小的矩形。这个矩形的边可以是任意方向，并不是限定于与坐标轴平行。该算法利用了最小外接矩形的一个性质：

> 点集的最小外接矩形的一条边与其凸包（凸包是一组点，凸包围成的多边形内的任何点的连线都会完全落在该多边形内。凸包这就像把橡皮筋绕在点上，然后取下与橡皮筋接触的点。）的一条边平行的特性。

利用这个性质，算法可以这样设计：

1. 将凸包的所有点连接在一起形成一个线段列表。
2. 遍历该线段列表，将点集的 $x$ 轴旋转到与当前遍历到的线段的方向上。
3. 找到点集的最顶部和最底部的 $y$ 值以及最左侧和最右侧的 $x$ 值。利用这四个值可以算出一个边界框面积。
4. 为了找到最小边界框，算法现在只需取面积最小的边界框。该边界框即为所求。

算法的效果如下图所示：

![alt text](figure/f19.png){height=500}

## 3 尺寸测量具体步骤与结果

### 3.1 预处理

这个项目提供的点云数据均如下**左图**所示：在 $z=0$ 的位置处会广泛地遍布着噪声点云，而目标点云仅仅是高于 $z=0$ 平面的一小部分，为了排除这些地面回波的干扰，使用```pcfitplane```函数（MATLAB的一个内置的基于MSAC算法的平面拟合函数）提取出平面（如下**中图**），然后扣除该平面，得到目标点云（如下**右图**）。这样处理过后的点云将成为后续处理的原始点云。

![alt text](figure/f20.png)

### 3.2 Task1

在这个项目中，Task1被用于校对测量程序和以及得出尺度变换因子（即将点云数据的尺度映射到真实尺度）。完成这一任务的步骤如下所示：

1. 观察四组点云数据，发现其中三组点云数据比较可靠，并将其分别用作几何尺寸测量的原始数据。
2. 使用```pcfitplane```函数检测出平面。
3. 将该平面的最高点视作长方体的高。
4. 使用PCA算法进一步去除噪声，并降维至二维平面上。
5. 使用最小外接矩形算法求出平面的长和宽，并将其视为长方体的长和宽。
6. 将通过这三组数据计算出来的长宽高分别求平均，将其作为最终的测量结果。
7. 参考已经标定好的数据，计算出尺度变换因子。

结果如下：

![alt text](figure/f21.png)
![alt text](figure/f22.png){height=500}

```MATLAB
The length is: 60.387119
The width is: 29.811153
The height is: 29.997723
The RATIO is: 1.0092505e+03
```

### 3.3 Task2

完成这一任务的步骤如下所示：

1. 观察四组点云数据，发现其中两组点云数据比较可靠，并将其分别用作几何尺寸测量的原始数据。
2. 使用```pcfitplane```函数检测出平面。
3. 将该平面的最高点视作圆柱体的高。
4. 使用PCA算法进一步去除噪声，并降维至二维平面上。
5. 使用最小圆覆盖算法求出圆平面的直径，并将其视为圆柱体的直径。
6. 将通过这两组数据计算出来的直径和高分别求平均，将其作为最终的测量结果。
7. 参考已经标定好的数据，计算出真实尺寸。

![alt text](figure/f23.png)
![alt text](figure/f24.png){height=500}

```MATLAB
The diameter is: 40.990364 mm
The height is: 40.868435 mm
```

### 3.3 Task3

这一任务比较复杂，由于观察到只有一组数据比较可靠，而且为了完成三棱锥顶部的夹角的计算，需要得到 $3$ 个侧面的方程，因此这里的步骤要稍微复杂一些，参见下面的步骤 $2,3,4$ 。完成这一任务的步骤如下所示：

1. 观察四组点云数据，发现只有一组点云数据比较可靠，并将其分别用作几何尺寸测量的原始数据。
2. **在三棱锥点云数据的 $3$ 个侧面上，人工标注出的 $3$ 个点，通过这 $3$ 个点先粗糙地计算出这 $3$ 个侧面的法向量。**
3. **将过步骤 $2$ 求得的法向量，作为```pcfitplane```函数的参考向量，以提高各个平面的拟合准确度，并最终得到 $3$ 个平面的方程。**
4. **联合步骤 $3$ 的方程与 $z=0$， 可以求出三棱锥的顶点和底部与水平面交界的两个端点。**
5. 计算底部两个端点的距离，作为三棱锥的底边长。
6. 使用顶点和底部的两个端点，可得到三棱柱的两条侧边，并计算出顶部的夹角（交线法）。
7. 参考已经标定好的数据，计算出真实尺寸。

结果如下：

![alt text](figure/f25.png)

```MATLAB
The degree of A calculated by intersection line is: 40.854599°
The length of B is: 31.021509 mm
```
